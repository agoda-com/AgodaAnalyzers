# Avoid Using WaitForResponseAsync in Playwright Tests

ID: AG0049

Type: Bug / Test Reliability

## Summary

Avoid using `WaitForResponseAsync` in Playwright tests as it can cause flaky tests due to race conditions. Instead, use `RunAndWaitForResponseAsync` to ensure the action that triggers the response is executed within the wait context, making tests more reliable.

## Explanation

`WaitForResponseAsync` in Playwright:
- Can cause race conditions when the response happens before the wait starts
- Creates flaky tests that may pass or fail unpredictably
- Doesn't guarantee that the action triggering the response happens after the wait begins
- Makes tests timing-dependent and unreliable in different environments
- Can lead to false positives or missed responses

`RunAndWaitForResponseAsync` provides:
- Guaranteed execution order (action happens after wait is set up)
- Elimination of race conditions
- More reliable and predictable test behavior
- Better test stability across different environments

### Don't ❌

```csharp
// BAD: Race condition - response might happen before wait starts
var response = await Page.WaitForResponseAsync(response => response.Url.Contains("api/create"));
await ClickCreateButton(); // This might trigger response before wait is active

// BAD: Using WaitForResponseAsync with string URL pattern
var response = await Page.WaitForResponseAsync("**/api/users");

// BAD: Using WaitForResponseAsync with regex
var response = await Page.WaitForResponseAsync(new Regex(@"api\/\w+"));

// BAD: Using WaitForResponseAsync with complex predicate
var response = await Page.WaitForResponseAsync(response => 
    response.Url.Matches(elementSelector) && response.Status == 200);
```

### Do ✅

```csharp
// GOOD: Action is guaranteed to happen after wait is set up
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await ClickCreateButton();
}, response => response.Url.Contains("api/create"));

// GOOD: Complex action with multiple steps
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await Page.FillAsync("#username", "testuser");
    await Page.FillAsync("#password", "password");
    await Page.ClickAsync("#login-button");
}, response => response.Url.Contains("api/login"));

// GOOD: Complex response validation
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await ClickCreateButton();
}, response =>
{
    var requestBody = response.Request.PostDataJSON().ToString();
    return response.Url.Matches(RequestBulkCreatePromotion) &&
           selectedCustomerSegments.All(id => requestBody.Contains($"\"CustomerSegmentGroupId\":{id}"));
});

// GOOD: Validate response status
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await Page.ClickAsync("#submit-button");
}, response => response.Url.Contains("api/submit"));
response.Status.ShouldBe(200);
```

## Why Avoid WaitForResponseAsync?

### Race Condition Issues
- The response might occur before `WaitForResponseAsync` starts listening
- No guarantee of execution order between wait setup and triggering action
- Timing-dependent behavior that varies across environments

### Test Flakiness
- Tests may pass locally but fail in CI/CD environments
- Inconsistent behavior due to timing differences
- Difficult to reproduce and debug failures

### Reliability Problems
- False negatives when responses are missed
- False positives when unrelated responses match the predicate
- Unpredictable test outcomes

## Best Practices

1. **Always use RunAndWaitForResponseAsync**:
   - Ensures proper execution order
   - Eliminates race conditions
   - Provides reliable test behavior

2. **Structure your actions properly**:
   - Put all triggering actions inside the action lambda
   - Keep response validation in the predicate
   - Validate response properties after the await

3. **Use specific response predicates**:
   - Match specific URL patterns
   - Validate request/response data when needed
   - Check response status codes

4. **Handle complex scenarios**:
   - Multiple actions can be performed in the action lambda
   - Complex validation logic in the response predicate
   - Combine with other Playwright waiting methods as needed

## Common Patterns

### Form Submission
```csharp
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await Page.FillAsync("#form-field", "value");
    await Page.ClickAsync("#submit-button");
}, response => response.Url.Contains("api/submit"));
```

### API Call with Data Validation
```csharp
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await TriggerApiCall();
}, response =>
{
    var requestBody = response.Request.PostDataJSON().ToString();
    return response.Url.Contains("api/endpoint") && 
           requestBody.Contains("expectedData");
});
```

### Multiple Step Actions
```csharp
var response = await Page.RunAndWaitForResponseAsync(async () =>
{
    await Page.SelectOptionAsync("#dropdown", "option1");
    await Page.CheckAsync("#checkbox");
    await Page.ClickAsync("#process-button");
}, response => response.Url.Matches(@".*\/api\/process$"));
```

Remember: The goal is to write reliable, non-flaky tests that behave consistently across all environments.

## References

- [Playwright RunAndWaitForResponseAsync](https://playwright.dev/dotnet/docs/api/class-page#page-run-and-wait-for-response)
- [Playwright WaitForResponseAsync](https://playwright.dev/dotnet/docs/api/class-page#page-wait-for-response)
- [Playwright Best Practices](https://playwright.dev/dotnet/docs/best-practices)
