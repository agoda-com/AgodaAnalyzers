# Don't Use XPath Selectors in Playwright Locators

ID: AG0045

Type: Bug / Test Reliability

## Summary

Avoid using XPath selectors in Playwright locators and test code as they create brittle tests that are tightly coupled to DOM structure. This analyzer detects XPath usage in method calls, variable declarations, constants, properties, and return statements. Instead, use Playwright's recommended locator strategies.

## Explanation

XPath selectors in Playwright:
- Create brittle tests that break with minor UI changes
- Are difficult to read and maintain
- Are tightly coupled to DOM structure
- Are generally slower than other selector strategies
- Don't leverage Playwright's powerful built-in locators
- Often copied from browser dev tools without proper consideration

### Don't ❌

```csharp
// BAD: Using raw XPath copied from browser dev tools
await page.Locator("//div[3]/table/tr[2]/td[1]/span/button").ClickAsync();

// BAD: Using explicit XPath prefix
await page.Locator("xpath=//button[@id='submit-button']").ClickAsync();

// BAD: XPath in variable
string buttonSelector = "//div[@class='form']/button";
await page.Locator(buttonSelector).ClickAsync();

// BAD: XPath in constants (common in page object models)
public const string XPathBaseDiscountInput = "//*[@data-element-name=\"ycs-channel-discounts-base-discount-input\"]";
public const string XPathSaveButton = "//*[@data-testid=\"footer-save-promotion\"]";
public const string XPathCxlPolicyOption = "//*[@data-selenium=\"channel-discount-cancellation-policy-selection-item-13308\"]";

// BAD: XPath in static readonly fields
private static readonly string XPathDeactivationFooterButton = "//*[@data-element-name=\"ycs-channel-discounts-deactivate-channel-button\"]";

// BAD: XPath in property initializers
public string XPathSelector { get; } = "//*[@data-testid=\"submit-button\"]";

// BAD: XPath in method return statements
public static string GetDatePickerXPath(string date) => $"//*[@data-day=\"{date}\"]";

// BAD: Using XPath axes
await page.Locator("//div[contains(@class,'menu')]/following-sibling::div").ClickAsync();

// BAD: Complex XPath expressions
await page.Locator("//div[contains(@class,'menu')]/following-sibling::div[@data-testid='item']").ClickAsync();
```

### Do ✅

```csharp
// GOOD: Using role-based locator
await page.GetByRole(AriaRole.Button, new() { Name = "Submit" }).ClickAsync();

// GOOD: Using text-based locator
await page.GetByText("Sign Up").ClickAsync();

// GOOD: Using test ID (recommended for testing)
await page.GetByTestId("submit-button").ClickAsync();

// GOOD: Using accessible label
await page.GetByLabel("Username").FillAsync("user123");

// GOOD: Using CSS when necessary (still better than XPath)
await page.Locator(".submit-container > button.primary").ClickAsync();

// GOOD: Constants using proper locator strategies
public const string BaseDiscountInputTestId = "ycs-channel-discounts-base-discount-input";
public const string SaveButtonTestId = "footer-save-promotion";
public const string CxlPolicyOptionTestId = "channel-discount-cancellation-policy-selection-item-13308";

// GOOD: Using the constants with proper locators
await page.GetByTestId(BaseDiscountInputTestId).FillAsync("10");
await page.GetByTestId(SaveButtonTestId).ClickAsync();

// GOOD: Method returning proper locator strategies
public static string GetDatePickerTestId(string date) => $"date-picker-{date}";
public ILocator GetDatePicker(string date) => Page.GetByTestId(GetDatePickerTestId(date));

// GOOD: Properties using proper locator strategies
public ILocator SaveButton => Page.GetByTestId("submit-button");
public ILocator DeactivationButton => Page.GetByRole(AriaRole.Button, new() { Name = "Deactivate" });
```

## Why Avoid XPath?

- Brittle tests that break with minor UI changes
- Poor readability and maintainability
- Tight coupling to DOM structure
- Slower execution compared to other selectors
- Miss out on Playwright's powerful locator features
- Often copied from browser tools without proper consideration
- Harder to debug when tests fail

## Detection Scope

This analyzer detects XPath usage in:

- **Method calls**: `page.Locator("//div[@class='form']")`
- **Variable declarations**: `string selector = "//button[@id='submit']";`
- **Constant declarations**: `public const string XPathSelector = "//*[@data-testid='button']";`
- **Static readonly fields**: `private static readonly string XPath = "//div";`
- **Property initializers**: `public string Selector { get; } = "//button";`
- **Return statements**: `return "//div[@class='container']";`
- **Interpolated strings**: `$"//*[@data-day='{date}']"`
- **Multiple variable declarations**: `string a = "valid", b = "//xpath";`

## Best Practices

1. **Use role-based selectors (Preferred)**:
   - `GetByRole()` - Most reliable and accessible
   - `GetByText()` - For text content
   - `GetByLabel()` - For form labels
   - `GetByPlaceholder()` - For input placeholders

2. **Use test-specific attributes**:
   - `GetByTestId()` - Add data-testid attributes for testing
   - Most reliable for test automation
   - Store test IDs as constants, not XPath expressions

3. **Page Object Model patterns**:
   - Store test IDs as string constants
   - Use ILocator properties that return proper locators
   - Avoid storing XPath strings in constants

4. **Use CSS selectors as fallback**:
   - More stable than XPath
   - Better performance
   - Still maintainable

5. **Avoid structure-dependent selectors**:
   - Don't rely on element position
   - Don't use complex DOM paths
   - Don't copy selectors from browser tools
   - Don't use XPath axes (following-sibling, parent, etc.)

Remember: The goal is to write maintainable, reliable tests that don't break with minor UI changes.

## References

- [Playwright Locators](https://playwright.dev/dotnet/docs/locators)
- [Playwright Best Practices](https://playwright.dev/dotnet/docs/best-practices)
- [Playwright Selectors](https://playwright.dev/dotnet/docs/selectors) 